/*
 * Windows Registry Settings Handler
 *
 * Copyright 2018 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    child_process = require("child_process"),
    os = require("os"),
    fs = require("fs"),
    path = require("path"),
    rimraf = require("rimraf"),
    edge = process.versions.electron ? require("electron-edge-js") : require("edge-js"),
    child_process = require("child_process");

var appLauncher = edge.func({
    source: path.join(__dirname, "../cs/AppLauncher.csx"),
    references: ["System.Management.dll"]
});

require("../../processHandling/processHandling.js");

var gpii = fluid.registerNamespace("gpii");
var windows = fluid.registerNamespace("gpii.windows");

var processesBridge = gpii.processes.windows();

fluid.registerNamespace("gpii.windows");
fluid.module.register("gpii.windows.startMenuLayoutHandlerModule", __dirname, require);
fluid.registerNamespace("gpii.windows.startMenuLayoutHandler");

gpii.windows.startMenuLayoutHandler.psLayoutHandler = function (file, operation) {
    var promise = fluid.promise();
    var command =
        // -Executable-
        "powershell.exe" +
        // -- args ---
        // Prevent logo
        " -NoLogo" +
        // Bypass execution policy
        " -ExecutionPolicy ByPass" +
        // Select the script
        " -File " +  __dirname + "\\..\\ps\\StartLayout.ps1" +
        // First script parameter
        " -Path \"" + file + "\" " +
        // Second script parameter
        " -Set " + operation;

    child_process.exec(command , function (err, stdout ) { // , stderr) {
        if (err) {
            promise.reject({
                isError: true,
                message: err.toString()
            });
            return;
        }
        var outputWords = stdout.split("\r\n");
        var outputType = outputWords[0];

        if (outputType === "Error") {
            promise.reject({
                isError: true,
                message: outputWords[1]
            });
        } else {
            promise.resolve();
        }
    });

    return promise;
};

gpii.windows.startMenuLayoutHandler.getShellExperienceFullName = function () {
    var promise = fluid.promise();

    var command =
        // -Executable-
        "powershell.exe" +
        // -- args ---
        // Prevent logo
        " -NoLogo" +
        // Bypass execution policy
        " -ExecutionPolicy ByPass" +
        // Select the script
        " -Command " + "Get-AppxPackage -Name 'Microsoft.Windows.ShellExperienceHost'";

    child_process.exec(command , function (err, stdout ) {
        if (err) {
            promise.reject({
                isError: true,
                message: err.toString()
            });
            return;
        } else {
            var lines = stdout.split(/\r?\n/);
            var tagElemArray = [];

            fluid.each(lines, function (line) {
                var lineElems = line.split("  : ");
                tagElemArray.push(lineElems);
            });

            var fullName = null;
            fluid.each(tagElemArray, function (tagElem) {
                if (tagElem.length >= 2 && tagElem[0].trim() === "PackageFullName") {
                    fullName = tagElem[1].trim();
                }
            });

            promise.resolve(fullName);
        }
    });

    return promise;
};

gpii.windows.waitForProcessSuspend = function (pName, options) {
    var checkSleeping = function () {
        var procs = processesBridge.findProcessesByCommand(pName);

        var sleeping = true;

        for (var n = 0, len = procs.length; n < len; n++) {
            if (procs[n].state !== "Suspended") {
                sleeping = false;
            }
        }

        return sleeping;
    };

    var error = {
        isError: true,
        message: "Timeout waiting for '" + pName + "' process to be in suspened state."
    };
    options.error = error;

    var promise = gpii.windows.waitForCondition(checkSleeping, options);
    return promise;
};

var startMenuShellProc = "ShellExperienceHost.exe";

gpii.windows.startMenuLayoutHandler.stopStartShellExperience = function () {
    var promise = fluid.promise();
    var procs = processesBridge.findProcessesByCommand(startMenuShellProc);

    var noProcess = function (array) {
        return !array.length;
    };
    var justOneProcess = function (array) {
        return array.length > 1;
    };

    if (noProcess(procs) || justOneProcess(procs)) {
        var errMessage = "";
        if (noProcess(procs)) {
            errMessage = "Unable to find 'startMenuShell' process.";
        } else {
            errMessage = "Found more than one 'startMenuShell' to find process.";
        }

        promise.reject({
            isError: true,
            message: errMessage,
            code: "noSuchProcess"
        });
    } else {
        var waitForShellState = function (options) {
            var sPromise = fluid.promise();

            gpii.windows.waitForProcessStart(startMenuShellProc, options).then(
                function () {
                    options.timeout = 30000;
                    gpii.windows.waitForProcessSuspend(startMenuShellProc, options).then(
                        function () {
                            sPromise.resolve();
                        },
                        function () {
                            sPromise.reject({
                                isError: true,
                                message: "Timeout waiting for shell process to be suspended.",
                                code: "suspendTimeout"
                            });
                        }
                    );
                },
                function () {
                    sPromise.reject({
                        isError: true,
                        message: "Timeout waiting for shell process to be started.",
                        code: "startTimeout"
                    });
                }
            );

            return sPromise;
        };

        var pr = gpii.windows.killProcessByName(startMenuShellProc, -1 >>> 0);

        if (pr.length === 0) {
            var options = {
                pollDelay: 200,
                timeout: 2000
            };

            var startMenuShell = function (startPromise) {
                var pShellName = gpii.windows.startMenuLayoutHandler.getShellExperienceFullName();

                pShellName.then(
                    function (shellName) {
                        var pid = appLauncher(shellName, true);
                        if (pid) {
                            startPromise.resolve(pid);
                        } else {
                            startPromise.reject({
                                isError: true,
                                message: "Starting menu shell app failed"
                            });
                        }
                    },
                    function (err) {
                        startPromise.reject(err);
                    }
                );

                return startPromise;
            };

            waitForShellState(options).then(
                function () {
                    promise.resolve();
                },
                function (err) {
                    if (err.code === "startTimeout") {
                        var startPromise = fluid.promise();
                        startMenuShell(startPromise);

                        if (startPromise.disposition === "reject") {
                            startPromise.then(
                                function () {},
                                function (err) {
                                    promise.reject(err);
                                }
                            );
                        } else {
                            waitForShellState(options).then(
                                function () {
                                    promise.resolve();
                                },
                                function (err) {
                                    promise.reject(err);
                                }
                            );
                        }
                    } else {
                        promise.reject(err);
                    }
                }
            );
        } else {
            promise.reject(err);
        }
    }

    return promise;
};

gpii.windows.startMenuLayoutHandler.fixMenuLayout = function (layoutPath) {
    var promise = fluid.promise();

    var baseKey = "HKEY_CURRENT_USER";
    var path = "Software\\Policies\\Microsoft\\Windows\\Explorer";

    var layoutFileKey = "StartLayoutFile";
    var startMenuDataType = "REG_SZ";
    var fixedMenuKey = "LockedStartLayout";
    var fixedMenuKeyDataType = "REG_DWORD";

    var fixedMenuValue = 1;
    var layoutValue = layoutPath;

    if (layoutPath === undefined) {
        fixedMenuValue = undefined;
        layoutValue = undefined;
    }

    var layoutStatus = gpii.windows.writeRegistryKey(baseKey, path, layoutFileKey, layoutValue, startMenuDataType);
    var fixedStatus = gpii.windows.writeRegistryKey(baseKey, path, fixedMenuKey, fixedMenuValue, fixedMenuKeyDataType);

     if (layoutStatus.statusCode !== 200 && fixedStatus.statusCode !== 200) {
        promise.reject({
            isError:true,
            message: "startMenuLayoutHandler: Failed to set the registry key."
        });
    } else {
        promise.resolve(layoutPath);
    }

     return promise;
};

gpii.windows.startMenuLayoutHandler.handlerImpl = function (payload, operation) {
    var promise = fluid.promise();

    var layoutTempDir = fs.mkdtempSync(path.join(os.tmpdir(), "gpii-desktop-layout"));
    var oldLayoutPath = path.join(layoutTempDir, "old-layout.xml");
    var newLayoutPath = path.join(layoutTempDir, "new-layout.xml");

    var cleanTmpDir = function () {
        try {
            rimraf.sync(layoutTempDir);
        } catch (err) {
            fluid.log("Warning: Deleting tem dir for start layouts failed with error: '" + err + "'");
        }
    };

    gpii.windows.startMenuLayoutHandler.psLayoutHandler(oldLayoutPath, "get").then(
        function () {
            var results = {};
            var settingsArray = fluid.makeArray(payload.settings);
            var uniqueSetting = settingsArray[0];
            // Get the payload value to set.
            var settingKey = fluid.keys(uniqueSetting)[0];

            var oldLayoutValue = fs.readFileSync(oldLayoutPath, "utf8");

            if (operation === "set") {
                var newLayout = fluid.values(uniqueSetting)[0].value;
                fluid.set(results, settingKey + ".oldValue.value", oldLayoutValue);

                fs.writeFileSync(newLayoutPath, newLayout);

                var changeLayout = function (value) {
                    var pFixedLayout = gpii.windows.startMenuLayoutHandler.fixMenuLayout(value);

                    var pChangeLayout = fluid.promise();

                    pFixedLayout.then(
                        function (settedPath) {
                            var restarted = gpii.windows.startMenuLayoutHandler.stopStartShellExperience();
                            restarted.then(
                                function () {
                                    pChangeLayout.resolve(settedPath);
                                },
                                function (err) {
                                    pChangeLayout.reject(err);
                                }
                            )
                        },
                        function (err) {
                            pChangeLayout.reject(err);
                        }
                    );

                    return pChangeLayout;
                };

                changeLayout(newLayoutPath).then(
                    function () {
                        changeLayout(undefined).then(
                            function () {
                                gpii.windows.startMenuLayoutHandler.psLayoutHandler(newLayoutPath, "get").then(
                                    function () {
                                        var newLayoutValue = fs.readFileSync(newLayoutPath, "utf8");
                                        fluid.set(results, settingKey + ".newValue.value", newLayoutValue);
                                        promise.resolve(results);

                                        cleanTmpDir();
                                    },
                                    function (err) {
                                        promise.reject({
                                            isError: true,
                                            message: err
                                        });

                                        cleanTmpDir();
                                    }
                                );
                            },
                            function (err) {
                                promise.reject(err);
                                cleanTmpDir();
                            }
                        );
                    },
                    function (err) {
                        promise.reject(err);
                        cleanTmpDir();
                    }
                );

            } else {
                results[settingKey] = { value: oldLayoutValue };

                promise.resolve(results);
                cleanTmpDir();
            }
        },
        function (err) {
            var msg = "Failed to retrieve current start-menu layout with error: '";
            promise.reject({
                isError: true,
                message: msg + err.message + "'"
            });
            cleanTmpDir();
        }
    );

    return promise;
};

gpii.windows.startMenuLayoutHandler.setImpl = function (payload) {
    return gpii.windows.startMenuLayoutHandler.handlerImpl(payload, "set");
};

gpii.windows.startMenuLayoutHandler.getImpl = function (payload) {
    return gpii.windows.startMenuLayoutHandler.handlerImpl(payload, "get");
};

gpii.windows.startMenuLayoutHandler.set = function (payload) {
    return gpii.settingsHandlers.invokeSettingsHandler(gpii.windows.startMenuLayoutHandler.setImpl, payload);
};

gpii.windows.startMenuLayoutHandler.get = function (payload) {
    return gpii.settingsHandlers.invokeSettingsHandler(gpii.windows.startMenuLayoutHandler.getImpl, payload);
};

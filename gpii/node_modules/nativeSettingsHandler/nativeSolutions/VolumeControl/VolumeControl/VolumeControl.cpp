// VolumeControl.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include "pch.h"
#include <iostream>
#include <mmdeviceapi.h>
#include <Endpointvolume.h>

#include <string>
#include <vector>

// Operation constants
const wchar_t* Get = L"Get";
const wchar_t* Set = L"Set";
const wchar_t* SetNear = L"SetNear";

const wchar_t* Mute = L"Mute";
const wchar_t* Volume = L"Volume";

using std::wstring;
using std::vector;

vector<wstring> supOpModes { Get, Set, SetNear };
vector<wstring> supOpIds { Mute, Volume };

struct Payload {
    wstring mode;
    wstring op;
    float value;
};

/**
 * Returns true if the parameters are correct, false otherwise.
 */
BOOL checkParams(int argc, wchar_t* argv[], Payload& payload) {
    // Payload
    std::wstring mode;
    std::wstring opId;

    if (argc == 3) {
        mode = argv[1];
        opId = argv[2];

        auto supOp = std::find(supOpIds.begin(), supOpIds.end(), opId) != supOpIds.end();

        if (mode == Get && supOp) {
            payload = { mode, opId, 0.0 };
            return 1;
        }
    } else if (argc == 4) {
        mode = argv[1];
        opId = argv[2];
        wstring strVal = argv[3];

        if (mode == Set || mode == SetNear) {
            auto supOp = std::find(supOpIds.begin(), supOpIds.end(), opId) != supOpIds.end();

            // Parse the received string into a float
            const wchar_t* start = strVal.c_str();
            wchar_t* end = NULL;

            float value = std::wcstof(start, &end) ;
            auto validVal = !((value == 0) && (end == start));
            auto correctRange = false;

            if (validVal) {
                if (opId == Volume) {
                    correctRange = value <= 1.0 && value >= 0.0;
                } else {
                    correctRange = value == 0 || value == 1;
                }
            }

            if (supOp && validVal && correctRange) {
                payload = { mode, opId, value };
                return 1;
            }
        }
    }

    return 0;
}

int wmain(int argc, wchar_t *argv[]) {
    // Payload
    Payload payload;
    BOOL pCheck = checkParams(argc, argv, payload);

    if (!pCheck) {
        std::wcout <<  L"{ \"code\": \"160\", \"message\": \"EINVAL\" }";

        return 0;
    }

    // COM Interfaces
    HRESULT hr = NULL;
    const CLSID CLSID_MMDeviceEnumerator = __uuidof(MMDeviceEnumerator);
    const IID IID_IMMDeviceEnumerator = __uuidof(IMMDeviceEnumerator);
    IMMDeviceEnumerator* pEnumerator;
    LPVOID pvReserved = NULL;

    hr = CoInitialize(pvReserved);
    if (hr != S_OK) {
        std::wcout << L"{ \"code\": \"" << std::to_wstring(hr) << "\", \"message\": \"Failed to initialize COM\" }";
    }

    hr = CoCreateInstance(
        CLSID_MMDeviceEnumerator,
        NULL,
        CLSCTX_ALL,
        IID_IMMDeviceEnumerator,
        (void**)&pEnumerator
    );
    if (hr != S_OK) {
        std::wcout << L"{ \"code\": \"" << std::to_wstring(hr) << "\", \"message\": \"Failed to initialize COM instance\" }";
    }

    IMMDevice* pAudioDevice;
    hr = pEnumerator->GetDefaultAudioEndpoint(eRender, eMultimedia, &pAudioDevice);
    if (hr != S_OK) {
        std::wcout << L"{ \"code\": \"" << std::to_wstring(hr) << "\", \"message\": \"Failed to get default audio endpoint\" }";
    }

    IAudioEndpointVolume* pEndpointVolume;
    pAudioDevice->Activate(__uuidof(IAudioEndpointVolume), CLSCTX_ALL, NULL, (void**)&pEndpointVolume);
    if (hr != S_OK) {
        std::wcout << L"{ \"code\": \"" << std::to_wstring(hr) << "\", \"message\": \"Failed to activate the audio endpoint\" }";
    }

    if (payload.mode == Get) {
        if (payload.op == Volume) {
            float curVolume = 0;
            hr = pEndpointVolume->GetMasterVolumeLevelScalar(&curVolume);
            if (hr != S_OK) {
                std::wcout << L"{ \"code\": \"" << std::to_wstring(hr) << "\", \"message\": \"Failed to get current system volume\" }";
            } else {
                std::wcout << L"{ \"Value\": \"" << std::to_wstring(curVolume) << "\" }";
            }
        } else {
            BOOL muted;
            hr = pEndpointVolume->GetMute(&muted);

            std::wcout << L"{ \"Value\": \"" << std::to_wstring(muted) << "\" }";
        }
    } else if (payload.mode == Set || payload.mode == SetNear) {
        if (payload.op == Volume) {
            float curVolume = 0;
            hr = pEndpointVolume->GetMasterVolumeLevelScalar(&curVolume);

            if (payload.mode == SetNear && hr == S_OK) {
                // Set the volume to near the target volume, allowing a small amount for the UI to finish the job.
                if (abs(payload.value - curVolume) > 0.02) {
                    payload.value += (payload.value > curVolume) ? static_cast<float>(-0.02) : static_cast<float>(0.02);
                } else  {
                    payload.value = curVolume;
                }
            }

            if (payload.mode == Set || payload.value != curVolume) {
                hr = pEndpointVolume->SetMasterVolumeLevelScalar(payload.value, NULL);
            }

            if (hr != S_OK) {
                std::wcout << L"{ \"code\": \"" << std::to_wstring(hr) << "\", \"message\": \"Failed to set current system volume\" }";
            } else {
                float newVolume = 0;
                if (pEndpointVolume->GetMasterVolumeLevelScalar(&newVolume) != S_OK) {
                    newVolume = payload.value;
                }
                std::wcout << L"{ \"Value\": \"" << std::to_wstring(newVolume) << "\", \"Old\": \""
                    << std::to_wstring(curVolume) << "\" }";
            }
        } else {
            hr = pEndpointVolume->SetMute(static_cast<BOOL>(payload.value), NULL);
            if (hr != S_OK) {
                std::wcout << L"{ \"code\": \"" << std::to_wstring(hr) << "\", \"message\": \"Failed to mute system volume\" }";
            } else {
                BOOL muted;
                hr = pEndpointVolume->GetMute(&muted);

                std::wcout << L"{ \"Value\": \"" << std::to_wstring(muted) << "\" }";
            }
        }
    }

    return 0;
}
